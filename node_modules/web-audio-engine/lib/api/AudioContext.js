"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var impl = require("../impl");
var util = require("../util");
var EventTarget = require("./EventTarget");
var AudioDestinationNode = require("./AudioDestinationNode");
var AudioListener = require("./AudioListener");
var AudioBuffer = require("./AudioBuffer");
var AudioBufferSourceNode = require("./AudioBufferSourceNode");
var ScriptProcessorNode = require("./ScriptProcessorNode");
var AnalyserNode = require("./AnalyserNode");
var GainNode = require("./GainNode");
var DelayNode = require("./DelayNode");
var BiquadFilterNode = require("./BiquadFilterNode");
var IIRFilterNode = require("./IIRFilterNode");
var WaveShaperNode = require("./WaveShaperNode");
var PannerNode = require("./PannerNode");
var SpatialPannerNode = require("./SpatialPannerNode");
var StereoPannerNode = require("./StereoPannerNode");
var ConvolverNode = require("./ConvolverNode");
var ChannelSplitterNode = require("./ChannelSplitterNode");
var ChannelMergerNode = require("./ChannelMergerNode");
var DynamicsCompressorNode = require("./DynamicsCompressorNode");
var OscillatorNode = require("./OscillatorNode");
var PeriodicWave = require("./PeriodicWave");
var decoder = require("../decoder");

var AudioContext = function (_EventTarget) {
  _inherits(AudioContext, _EventTarget);

  function AudioContext(opts) {
    _classCallCheck(this, AudioContext);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AudioContext).call(this));

    util.defineProp(_this, "_impl", new impl.AudioContext(opts));

    _this._impl.$destination = new AudioDestinationNode(_this, _this._impl.getDestination());
    _this._impl.$listener = new AudioListener(_this, _this._impl.getListener());
    _this._impl.$onstatechange = null;
    return _this;
  }

  _createClass(AudioContext, [{
    key: "suspend",
    value: function suspend() {
      return this._impl.suspend();
    }
  }, {
    key: "resume",
    value: function resume() {
      return this._impl.resume();
    }
  }, {
    key: "close",
    value: function close() {
      return this._impl.close();
    }
  }, {
    key: "createBuffer",
    value: function createBuffer(numberOfChannels, length, sampleRate) {
      return new AudioBuffer(this, { numberOfChannels: numberOfChannels, length: length, sampleRate: sampleRate });
    }
  }, {
    key: "decodeAudioData",
    value: function decodeAudioData(audioData, successCallback, errorCallback) {
      var promise = decoder.decode(audioData, { sampleRate: this.sampleRate });

      promise.then(successCallback, errorCallback);

      return promise;
    }
  }, {
    key: "createBufferSource",
    value: function createBufferSource() {
      return new AudioBufferSourceNode(this);
    }

    /* istanbul ignore next */

  }, {
    key: "createAudioWorker",
    value: function createAudioWorker() {
      throw new TypeError("NOT SUPPORTED");
    }
  }, {
    key: "createScriptProcessor",
    value: function createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels) {
      return new ScriptProcessorNode(this, { bufferSize: bufferSize, numberOfInputChannels: numberOfInputChannels, numberOfOutputChannels: numberOfOutputChannels });
    }
  }, {
    key: "createAnalyser",
    value: function createAnalyser() {
      return new AnalyserNode(this);
    }
  }, {
    key: "createGain",
    value: function createGain() {
      return new GainNode(this);
    }
  }, {
    key: "createDelay",
    value: function createDelay(maxDelayTime) {
      return new DelayNode(this, { maxDelayTime: maxDelayTime });
    }
  }, {
    key: "createBiquadFilter",
    value: function createBiquadFilter() {
      return new BiquadFilterNode(this);
    }
  }, {
    key: "createIIRFilter",
    value: function createIIRFilter(feedforward, feedback) {
      return new IIRFilterNode(this, { feedforward: feedforward, feedback: feedback });
    }
  }, {
    key: "createWaveShaper",
    value: function createWaveShaper() {
      return new WaveShaperNode(this);
    }
  }, {
    key: "createPanner",
    value: function createPanner() {
      return new PannerNode(this);
    }
  }, {
    key: "createSpatialPanner",
    value: function createSpatialPanner() {
      return new SpatialPannerNode(this);
    }
  }, {
    key: "createStereoPanner",
    value: function createStereoPanner() {
      return new StereoPannerNode(this);
    }
  }, {
    key: "createConvolver",
    value: function createConvolver() {
      return new ConvolverNode(this);
    }
  }, {
    key: "createChannelSplitter",
    value: function createChannelSplitter(numberOfOutputs) {
      return new ChannelSplitterNode(this, { numberOfOutputs: numberOfOutputs });
    }
  }, {
    key: "createChannelMerger",
    value: function createChannelMerger(numberOfInputs) {
      return new ChannelMergerNode(this, { numberOfInputs: numberOfInputs });
    }
  }, {
    key: "createDynamicsCompressor",
    value: function createDynamicsCompressor() {
      return new DynamicsCompressorNode(this);
    }
  }, {
    key: "createOscillator",
    value: function createOscillator() {
      return new OscillatorNode(this);
    }
  }, {
    key: "createPeriodicWave",
    value: function createPeriodicWave(real, imag, constraints) {
      return new PeriodicWave(this, { real: real, imag: imag, constraints: constraints });
    }

    /* istanbul ignore next */

  }, {
    key: "createMediaElementSource",
    value: function createMediaElementSource() {
      throw new TypeError("NOT SUPPORTED");
    }

    /* istanbul ignore next */

  }, {
    key: "createMediaStreamSource",
    value: function createMediaStreamSource() {
      throw new TypeError("NOT SUPPORTED");
    }

    /* istanbul ignore next */

  }, {
    key: "createMediaStreamDestination",
    value: function createMediaStreamDestination() {
      throw new TypeError("NOT SUPPORTED");
    }
  }, {
    key: "destination",
    get: function get() {
      return this._impl.$destination;
    }
  }, {
    key: "sampleRate",
    get: function get() {
      return this._impl.getSampleRate();
    }
  }, {
    key: "currentTime",
    get: function get() {
      return this._impl.getCurrentTime();
    }
  }, {
    key: "listener",
    get: function get() {
      return this._impl.$listener;
    }
  }, {
    key: "state",
    get: function get() {
      return this._impl.getState();
    }
  }, {
    key: "onstatechange",
    get: function get() {
      return this._impl.$onstatechange;
    },
    set: function set(callback) {
      this._impl.replaceEventListener("statechange", this._impl.$onstatechange, callback);
      this._impl.$onstatechange = callback;
    }
  }]);

  return AudioContext;
}(EventTarget);

module.exports = AudioContext;