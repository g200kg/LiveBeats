"use strict";

var util = require("../../util");
var audioParamUtil = require("../../util/audioParamUtil");

var SET_VALUE_AT_TIME = 1;
var LINEAR_RAMP_TO_VALUE_AT_TIME = 2;
var EXPONENTIAL_RAMP_TO_VALUE_AT_TIME = 3;
var SET_TARGET_AT_TIME = 4;
var SET_VALUE_CURVE_AT_TIME = 5;
var CONTROL = 1;
var AUDIO = 2;

var AudioParamDSP = {
  dspInit: function dspInit() {
    this._prevValue = NaN;
    this._hasSampleAccurateValues = false;
    this._currentEventIndex = -1;
    this._quantumStartFrame = -1;
    this._remainSamples = 0;
    this._schedParams = {};
  },
  dspProcess: function dspProcess() {
    var input = this.inputs[0];
    var inputBus = input.bus;

    input.pull();

    var hasEvents = !!this._timeline.length;
    var hasInput = !inputBus.isSilent;
    var algorithm = hasEvents * 2 + hasInput;

    switch (algorithm) {
      case 0:
        // events: x / input: x
        return this.dspStaticValue();
      case 1:
        // events: x / input: o
        return this.dspInputAndOffset(inputBus);
      case 2:
        // events: o / input: x
        return this.dspEvents();
      case 3:
        // events: o / input: o
        return this.dspEventsAndInput(inputBus);
      default:
    }
  },
  dspStaticValue: function dspStaticValue() {
    var value = this._value;

    if (value !== this._prevValue) {
      if (value === 0) {
        this.outputBus.zeros();
      } else {
        util.fill(this.outputBus.getMutableData()[0], value);
      }
      this._prevValue = value;
    }

    this._hasSampleAccurateValues = false;
  },
  dspInputAndOffset: function dspInputAndOffset(inputBus) {
    var blockSize = this.blockSize;
    var outputBus = this.outputBus;
    var output = outputBus.getMutableData()[0];
    var input = inputBus.getChannelData()[0];
    var value = this._value;

    output.set(input);

    if (value !== 0) {
      for (var i = 0; i < blockSize; i++) {
        output[i] += value;
      }
    }

    this._prevValue = NaN;
    this._hasSampleAccurateValues = true;
  },
  dspEvents: function dspEvents() {
    var outputBus = this.outputBus;
    var output = outputBus.getMutableData()[0];

    this.dspValuesForTimeRange(output);

    this._prevValue = NaN;
    this._hasSampleAccurateValues = true;
  },
  dspEventsAndInput: function dspEventsAndInput(inputBus) {
    var blockSize = this.blockSize;
    var outputBus = this.outputBus;
    var output = outputBus.getMutableData()[0];
    var input = inputBus.getChannelData()[0];

    this.dspValuesForTimeRange(output);

    for (var i = 0; i < blockSize; i++) {
      output[i] += input[i];
    }

    this._prevValue = NaN;
    this._hasSampleAccurateValues = true;
  },
  dspValuesForTimeRange: function dspValuesForTimeRange(output) {
    var blockSize = this.blockSize;
    var quantumStartFrame = this.context.currentSampleFrame;
    var quantumEndFrame = quantumStartFrame + blockSize;
    var sampleRate = this.sampleRate;
    var timeline = this._timeline;

    var value = this._value;
    var writeIndex = 0;

    // processing until the first event
    if (this._currentEventIndex === -1) {
      var firstEventStartFrame = timeline[0].startFrame;

      // timeline
      // |----------------|----------------|-------*--------|----------------|
      // ^                ^                        ^
      // |                quantumEndFrame          firstEventStartFrame
      // quantumStartFrame
      // <---------------> fill value with in range
      if (quantumEndFrame <= firstEventStartFrame) {
        for (var i = 0; i < blockSize; i++) {
          output[i] = value;
        }
        this._hasSampleAccurateValues = false;
        return;
      }

      // timeline
      // |----------------|----------------|-------*--------|----------------|
      //                                   ^       ^        ^
      //                                   |       |        quantumEndFrame
      //                                   |       firstEventStartFrame
      //                                   quantumStartFrame
      //                                   <------> fill value with in range
      for (var _i = 0, imax = firstEventStartFrame - quantumStartFrame; _i < imax; _i++) {
        output[writeIndex++] = value;
      }
      this._currentEventIndex = 0;
    }

    this._hasSampleAccurateValues = true;

    var remainSamples = this._quantumStartFrame === quantumStartFrame ? this._remainSamples : 0;
    var schedParams = this._schedParams;

    // if new event exists, should recalculate remainSamples
    if (remainSamples === Infinity && this._currentEventIndex + 1 !== timeline.length) {
      remainSamples = timeline[this._currentEventIndex + 1].startFrame - quantumStartFrame;
    }

    while (writeIndex < blockSize && this._currentEventIndex < timeline.length) {
      var eventItem = timeline[this._currentEventIndex];
      var startFrame = eventItem.startFrame;
      var endFrame = eventItem.endFrame;

      // timeline
      // |-------*--------|-------*--------|----------------|----------------|
      //         ^                ^        ^                ^
      //         |<-------------->|        |                quantumEndFrame
      //         |                |        quantumStartFrame
      //         startFrame       endFrame
      // skip event if
      // (endFrame < quantumStartFrame): past event
      //  or
      // (startFrame === endFrame): setValueAtTime before linearRampToValueAtTime or exponentialRampToValueAtTime.
      if (endFrame < quantumStartFrame || startFrame === endFrame) {
        remainSamples = 0;
        this._currentEventIndex += 1;
        continue;
      }

      if (remainSamples <= 0) {
        var processedSamples = Math.max(0, quantumStartFrame - startFrame);

        switch (eventItem.type) {
          case SET_VALUE_AT_TIME:
            {
              value = eventItem.startValue;
              schedParams = { type: SET_VALUE_AT_TIME };
            }
            break;
          case LINEAR_RAMP_TO_VALUE_AT_TIME:
            {
              var valueRange = eventItem.endValue - eventItem.startValue;
              var frameRange = eventItem.endFrame - eventItem.startFrame;
              var grow = valueRange / frameRange;

              if (grow) {
                value = eventItem.startValue + processedSamples * grow;
                schedParams = { type: LINEAR_RAMP_TO_VALUE_AT_TIME, grow: grow };
              } else {
                value = eventItem.startValue;
                schedParams = { type: SET_VALUE_AT_TIME };
              }
            }
            break;
          case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            {
              var valueRatio = eventItem.endValue / eventItem.startValue;
              var _frameRange = eventItem.endFrame - eventItem.startFrame;
              var _grow = Math.pow(valueRatio, 1 / _frameRange);

              if (_grow) {
                value = eventItem.startValue * Math.pow(_grow, processedSamples);
                schedParams = { type: EXPONENTIAL_RAMP_TO_VALUE_AT_TIME, grow: _grow };
              } else {
                value = eventItem.startValue;
                schedParams = { type: SET_VALUE_AT_TIME };
              }
            }
            break;
          case SET_TARGET_AT_TIME:
            {
              var target = Math.fround(eventItem.args[0]);
              var timeConstant = eventItem.args[2];
              var discreteTimeConstant = 1 - Math.exp(-1 / (sampleRate * timeConstant));
              var time = (quantumStartFrame + writeIndex) / sampleRate;

              value = audioParamUtil.computeValueAtTime(timeline, time, this._userValue);

              if (discreteTimeConstant !== 1) {
                schedParams = { type: SET_TARGET_AT_TIME, target: target, discreteTimeConstant: discreteTimeConstant };
              } else {
                schedParams = { type: SET_VALUE_AT_TIME };
              }
            }
            break;
          case SET_VALUE_CURVE_AT_TIME:
            {
              var curve = eventItem.args[0];

              schedParams = { type: SET_VALUE_CURVE_AT_TIME, curve: curve, startFrame: startFrame, endFrame: endFrame };
            }
            break;
        }

        remainSamples = endFrame - startFrame - processedSamples;
      } // if (remainSamples === 0)

      var fillFrames = Math.min(blockSize - writeIndex, remainSamples);

      switch (schedParams.type) {
        case SET_VALUE_AT_TIME:
          {
            for (var _i2 = 0; _i2 < fillFrames; _i2++) {
              output[writeIndex++] = value;
            }
          }
          break;
        case LINEAR_RAMP_TO_VALUE_AT_TIME:
          {
            for (var _i3 = 0; _i3 < fillFrames; _i3++) {
              output[writeIndex++] = value;
              value += schedParams.grow;
            }
          }
          break;
        case EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          {
            for (var _i4 = 0; _i4 < fillFrames; _i4++) {
              output[writeIndex++] = value;
              value *= schedParams.grow;
            }
          }
          break;
        case SET_TARGET_AT_TIME:
          {
            for (var _i5 = 0; _i5 < fillFrames; _i5++) {
              output[writeIndex++] = value;
              value += (schedParams.target - value) * schedParams.discreteTimeConstant;
            }
          }
          break;
        case SET_VALUE_CURVE_AT_TIME:
          {
            var _curve = schedParams.curve;
            var schedRange = schedParams.endFrame - schedParams.startFrame;
            var schedStartFrame = schedParams.startFrame;

            for (var _i6 = 0; _i6 < fillFrames; _i6++) {
              var xx = (quantumStartFrame + writeIndex - schedStartFrame) / schedRange;
              var ix = xx * (_curve.length - 1);
              var i0 = ix | 0;
              var i1 = i0 + 1;

              value = _curve[i0] + ix % 1 * (_curve[i1] - _curve[i0]);
              output[writeIndex++] = value;
            }

            if (remainSamples === fillFrames) {
              value = _curve[_curve.length - 1];
            }
          }
          break;
      }

      remainSamples -= fillFrames;

      if (remainSamples === 0) {
        this._currentEventIndex += 1;
      }
    } // while (writeIndex < blockSize)

    while (writeIndex < blockSize) {
      output[writeIndex++] = value;
    }

    this._value = value;
    this._schedParams = schedParams;
    this._remainSamples = remainSamples;
    this._quantumStartFrame = quantumEndFrame;
  }
};

AudioParamDSP.SET_VALUE_AT_TIME = SET_VALUE_AT_TIME;
AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME = LINEAR_RAMP_TO_VALUE_AT_TIME;
AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME = EXPONENTIAL_RAMP_TO_VALUE_AT_TIME;
AudioParamDSP.SET_TARGET_AT_TIME = SET_TARGET_AT_TIME;
AudioParamDSP.SET_VALUE_CURVE_AT_TIME = SET_VALUE_CURVE_AT_TIME;
AudioParamDSP.CONTROL = CONTROL;
AudioParamDSP.AUDIO = AUDIO;

module.exports = AudioParamDSP;