"use strict";

var OscillatorNodeDSP = {
  dspInit: function dspInit() {
    this._phase = 0;
  },
  dspProcess: function dspProcess() {
    var _this = this;

    var blockSize = this.blockSize;
    var quantumStartFrame = this.context.currentSampleFrame;
    var quantumEndFrame = quantumStartFrame + blockSize;
    var sampleOffset = Math.max(0, this._startFrame - quantumStartFrame);
    var fillToSample = Math.min(quantumEndFrame, this._stopFrame) - quantumStartFrame;
    var output = this.outputs[0].bus.getMutableData()[0];

    var writeIndex = 0;

    if (this._type === "sine") {
      writeIndex = this.dspSine(output, sampleOffset, fillToSample, this.sampleRate);
    } else {
      writeIndex = this.dspWave(output, sampleOffset, fillToSample, this.sampleRate);
    }

    // timeline
    // |----------------|-------*--------|----------------|----------------|
    //                  ^       ^        ^
    //                  |------>|        quantumEndFrame
    //                  | wrote |
    //                  |       stopFrame
    //                  quantumStartFrame
    if (this._stopFrame <= quantumStartFrame + writeIndex) {
      // rest samples fill zero
      while (writeIndex < blockSize) {
        output[writeIndex++] = 0;
      }

      this.context.addPostProcess(function () {
        _this.outputs[0].bus.zeros();
        _this.outputs[0].disable();
        _this.dispatchEvent({ type: "ended" });
      });
    }
  },
  dspSine: function dspSine(output, writeIndex, blockSize, sampleRate) {
    var frequency = this._frequency;
    var detune = this._detune;
    var algorithm = frequency.hasSampleAccurateValues() * 2 + detune.hasSampleAccurateValues();
    var frequencyToPhaseIncr = 2 * Math.PI / sampleRate;

    var phase = this._phase;

    if (algorithm === 0) {
      var frequencyValue = frequency.getValue();
      var detuneValue = detune.getValue();
      var computedFrequency = frequencyValue * Math.pow(2, detuneValue / 1200);
      var phaseIncr = frequencyToPhaseIncr * computedFrequency;

      while (writeIndex < blockSize) {
        output[writeIndex++] = Math.sin(phase);
        phase += phaseIncr;
      }
    } else {
      var frequencyValues = frequency.getSampleAccurateValues();
      var detuneValues = detune.getSampleAccurateValues();

      while (writeIndex < blockSize) {
        var _frequencyValue = frequencyValues[writeIndex];
        var _detuneValue = detuneValues[writeIndex];
        var _computedFrequency = _frequencyValue * Math.pow(2, _detuneValue / 1200);

        output[writeIndex++] = Math.sin(phase);
        phase += frequencyToPhaseIncr * _computedFrequency;
      }
    }

    this._phase = phase;

    return writeIndex;
  },
  dspWave: function dspWave(output, writeIndex, blockSize, sampleRate) {
    var frequency = this._frequency;
    var detune = this._detune;
    var algorithm = frequency.hasSampleAccurateValues() * 2 + detune.hasSampleAccurateValues();
    var waveTable = this._waveTable;
    var waveTableLength = waveTable.length - 1;
    var frequencyToPhaseIncr = 1 / sampleRate;

    var phase = this._phase;

    if (algorithm === 0) {
      var frequencyValue = frequency.getValue();
      var detuneValue = detune.getValue();
      var computedFrequency = frequencyValue * Math.pow(2, detuneValue / 1200);
      var phaseIncr = frequencyToPhaseIncr * computedFrequency;

      while (writeIndex < blockSize) {
        var idx = phase * waveTableLength % waveTableLength;
        var v0 = waveTable[idx | 0];
        var v1 = waveTable[(idx | 0) + 1];

        output[writeIndex++] = v0 + idx % 1 * (v1 - v0);
        phase += phaseIncr;
      }
    } else {
      var frequencyValues = frequency.getSampleAccurateValues();
      var detuneValues = detune.getSampleAccurateValues();

      while (writeIndex < blockSize) {
        var _frequencyValue2 = frequencyValues[writeIndex];
        var _detuneValue2 = detuneValues[writeIndex];
        var _computedFrequency2 = _frequencyValue2 * Math.pow(2, _detuneValue2 / 1200);
        var _idx = phase * waveTableLength % waveTableLength;
        var _v = waveTable[_idx | 0];
        var _v2 = waveTable[(_idx | 0) + 1];

        output[writeIndex++] = _v + _idx % 1 * (_v2 - _v);
        phase += frequencyToPhaseIncr * _computedFrequency2;
      }
    }

    this._phase = phase;

    return writeIndex;
  }
};

module.exports = OscillatorNodeDSP;