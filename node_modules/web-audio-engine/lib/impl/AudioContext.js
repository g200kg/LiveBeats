"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var util = require("../util");
var config = require("../config");
var EventTarget = require("./EventTarget");
var AudioDestinationNode = require("./AudioDestinationNode");
var AudioListener = require("./AudioListener");

/**
 * @prop {number} sampleRate
 * @prop {number} blockSize
 * @prop {number} numberOfChannels
 * @prop {number} currentTime
 * @prop {number} currentSampleFrame
 */

var AudioContext = function (_EventTarget) {
  _inherits(AudioContext, _EventTarget);

  /**
   * @param {object} opts
   * @param {number} opts.sampleRate
   * @param {number} opts.blockSize
   * @param {number} opts.numberOfChannels
   */

  function AudioContext(opts) {
    _classCallCheck(this, AudioContext);

    opts = opts || /* istanbul ignore next */{};

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AudioContext).call(this));

    var sampleRate = util.defaults(opts.sampleRate, config.sampleRate);
    var blockSize = util.defaults(opts.blockSize, config.blockSize);
    var numberOfChannels = util.defaults(opts.channels || opts.numberOfChannels, config.numberOfChannels);

    sampleRate = util.toValidSampleRate(sampleRate);
    blockSize = util.toValidBlockSize(blockSize);
    numberOfChannels = util.toValidNumberOfChannels(numberOfChannels);

    _this.sampleRate = sampleRate | 0;
    _this.blockSize = blockSize | 0;
    _this.numberOfChannels = numberOfChannels | 0;
    _this.currentTime = 0;
    _this.currentSampleFrame = 0;
    _this.state = "suspended";
    _this._destination = new AudioDestinationNode(_this, { numberOfChannels: numberOfChannels });
    _this._listener = new AudioListener(_this);
    _this._sched = {};
    _this._callbacksForPostProcess = null;
    _this._currentFrameIndex = 0;
    return _this;
  }

  /**
   * @return {AudioDestinationNode}
   */


  _createClass(AudioContext, [{
    key: "getDestination",
    value: function getDestination() {
      return this._destination;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getSampleRate",
    value: function getSampleRate() {
      return this.sampleRate;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getCurrentTime",
    value: function getCurrentTime() {
      return this.currentTime;
    }

    /**
     * @return {AudioListener}
     */

  }, {
    key: "getListener",
    value: function getListener() {
      return this._listener;
    }

    /**
     * @return {string}
     */

  }, {
    key: "getState",
    value: function getState() {
      return this.state;
    }

    /**
     * @return {Promise<void>}
     */

  }, {
    key: "suspend",
    value: function suspend() {
      if (this.state === "running") {
        return this.changeState("suspended");
      }
      return this.notChangeState();
    }

    /**
     * @return {Promise<void>}
     */

  }, {
    key: "resume",
    value: function resume() {
      if (this.state === "suspended") {
        return this.changeState("running");
      }
      return this.notChangeState();
    }

    /**
     * @return {Promise<void>}
     */

  }, {
    key: "close",
    value: function close() {
      if (this.state !== "closed") {
        return this.changeState("closed");
      }
      return this.notChangeState();
    }

    /**
     * @param {string} state
     * @return {Promise<void>}
     */

  }, {
    key: "changeState",
    value: function changeState(state) {
      var _this2 = this;

      this.state = state;
      return new Promise(function (resolve) {
        _this2.dispatchEvent({ type: "statechange" });
        resolve();
      });
    }

    /**
     * @return {Promise<void>}
     */

  }, {
    key: "notChangeState",
    value: function notChangeState() {
      return Promise.resolve();
    }

    /**
     * @param {number}   time
     * @param {function} task
     */

  }, {
    key: "sched",
    value: function sched(time, task) {
      var schedSampleFrame = Math.floor(time * this.sampleRate / this.blockSize) * this.blockSize | 0;

      if (!this._sched[schedSampleFrame]) {
        this._sched[schedSampleFrame] = [task];
      } else {
        this._sched[schedSampleFrame].push(task);
      }
    }

    /**
     * @param {function} task
     */

  }, {
    key: "addPostProcess",
    value: function addPostProcess(task) {
      if (this._callbacksForPostProcess === null) {
        this._callbacksForPostProcess = [task];
      } else {
        this._callbacksForPostProcess.push(task);
      }
    }

    /**
     * @param {Float32Array[]} channelData
     * @param {number}         offset
     */

  }, {
    key: "process",
    value: function process(channelData, offset) {
      var destination = this._destination;

      if (this.state !== "running") {
        var numberOfChannels = channelData.length;
        var offsetEnd = offset + this.blockSize;

        for (var ch = 0; ch < numberOfChannels; ch++) {
          util.fillRange(channelData[ch], offset, offsetEnd);
        }
      } else {
        var sched = this._sched;
        var currentSampleFrame = this.currentSampleFrame | 0;

        if (sched[currentSampleFrame]) {
          var tasks = sched[currentSampleFrame];

          for (var i = 0, imax = tasks.length; i < imax; i++) {
            tasks[i]();
          }

          delete sched[currentSampleFrame];
        }

        destination.process(channelData, offset);

        if (this._callbacksForPostProcess !== null) {
          var _tasks = this._callbacksForPostProcess;

          for (var _i = 0, _imax = _tasks.length; _i < _imax; _i++) {
            _tasks[_i]();
          }

          this._callbacksForPostProcess = null;
        }

        this.currentSampleFrame += this.blockSize;
        this.currentTime = this.currentSampleFrame / this.sampleRate;
      }
    }

    /**
     *
     */

  }, {
    key: "reset",
    value: function reset() {
      this.currentTime = 0;
      this.currentSampleFrame = 0;
      this.state = "suspended";
      this._destination = new AudioDestinationNode(this, { numberOfChannels: this.numberOfChannels });
      this._listener = new AudioListener(this);
      this._sched = [];
      this._callbacksForPostProcess = null;
    }
  }]);

  return AudioContext;
}(EventTarget);

module.exports = AudioContext;