"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = require("../util");
var AudioNodeInput = require("./core/AudioNodeInput");
var AudioBus = require("./core/AudioBus");
var AudioParamDSP = require("./dsp/AudioParam");

/**
 * @prop {AudioContext}      context
 * @prop {number}            blockSize
 * @prop {number}            sampleRate
 * @prop {AudioNodeInput[]}  inputs
 * @prop {AudioBus}          outputBus
 */

var AudioParam = function () {
  /**
   * @param {AudioContext} context
   * @param {string}       opts.rate - [ "audio", "control "]
   * @param {number}       opts.defaultValue
   */

  function AudioParam(context, opts) {
    _classCallCheck(this, AudioParam);

    opts = opts || /* istanbul ignore next */{};

    var rate = util.defaults(opts.rate, "control");
    var defaultValue = util.defaults(opts.defaultValue, 0);

    this.context = context;
    this.blockSize = context.blockSize;
    this.sampleRate = context.sampleRate;
    this.inputs = [new AudioNodeInput({
      node: this,
      index: 0,
      numberOfChannels: 1,
      channelCount: 1,
      channelCountMode: "explicit"
    })];
    this.outputBus = new AudioBus(1, this.blockSize, this.sampleRate);

    this._rate = this.fromRateName(rate);
    this._defaultValue = util.toNumber(defaultValue);
    this._value = this._defaultValue;
    this._userValue = this._value;
    this._timeline = [];

    this.dspInit(this._rate);
  }

  /**
   * @return {number}
   */


  _createClass(AudioParam, [{
    key: "getValue",
    value: function getValue() {
      return this._value;
    }

    /**
     * @param {number} value
     */

  }, {
    key: "setValue",
    value: function setValue(value) {
      this._value = this._userValue = util.toNumber(value);
    }

    /**
     * @return {number}
     */

  }, {
    key: "getDefaultValue",
    value: function getDefaultValue() {
      return this._defaultValue;
    }

    /**
     * @param {number} value
     * @param {number} startTime
     */

  }, {
    key: "setValueAtTime",
    value: function setValueAtTime(value, startTime) {
      value = util.toNumber(value);
      startTime = Math.max(0, util.toNumber(startTime));

      var eventItem = {
        type: AudioParamDSP.SET_VALUE_AT_TIME,
        time: startTime,
        args: [value, startTime],
        startFrame: Math.round(startTime * this.sampleRate),
        endFrame: Infinity,
        startValue: value,
        endValue: value
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case AudioParamDSP.SET_VALUE_AT_TIME:
          case AudioParamDSP.SET_TARGET_AT_TIME:
            prevEventItem.endFrame = eventItem.startFrame;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.startFrame;
            nextEventItem.startValue = eventItem.startValue;
            break;
        }
        eventItem.endFrame = nextEventItem.startFrame;
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} value
     * @param {number} endTime
     */

  }, {
    key: "linearRampToValueAtTime",
    value: function linearRampToValueAtTime(value, endTime) {
      value = util.toNumber(value);
      endTime = Math.max(0, util.toNumber(endTime));

      var eventItem = {
        type: AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME,
        time: endTime,
        args: [value, endTime],
        startFrame: 0,
        endFrame: Math.round(endTime * this.sampleRate),
        startValue: this._defaultValue,
        endValue: value
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case AudioParamDSP.SET_VALUE_AT_TIME:
          case AudioParamDSP.SET_TARGET_AT_TIME:
            eventItem.startFrame = prevEventItem.startFrame;
            eventItem.startValue = prevEventItem.startValue;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.SET_VALUE_CURVE_AT_TIME:
            eventItem.startFrame = prevEventItem.endFrame;
            eventItem.startValue = prevEventItem.endValue;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.endFrame;
            nextEventItem.startValue = eventItem.endValue;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} value
     * @param {number} endTime
     */

  }, {
    key: "exponentialRampToValueAtTime",
    value: function exponentialRampToValueAtTime(value, endTime) {
      value = Math.max(1e-6, util.toNumber(value));
      endTime = Math.max(0, util.toNumber(endTime));

      var eventItem = {
        type: AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME,
        time: endTime,
        args: [value, endTime],
        startFrame: 0,
        endFrame: Math.round(endTime * this.sampleRate),
        startValue: Math.max(1e-6, this._defaultValue),
        endValue: value
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case AudioParamDSP.SET_VALUE_AT_TIME:
          case AudioParamDSP.SET_TARGET_AT_TIME:
            eventItem.startFrame = prevEventItem.startFrame;
            eventItem.startValue = prevEventItem.startValue;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.SET_VALUE_CURVE_AT_TIME:
            eventItem.startFrame = prevEventItem.endFrame;
            eventItem.startValue = prevEventItem.endValue;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.endFrame;
            nextEventItem.startValue = eventItem.endValue;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} target
     * @param {number} startTime
     * @param {number} timeConstant
     */

  }, {
    key: "setTargetAtTime",
    value: function setTargetAtTime(target, startTime, timeConstant) {
      target = util.toNumber(target);
      startTime = Math.max(0, util.toNumber(startTime));
      timeConstant = Math.max(0, util.toNumber(timeConstant));

      var eventItem = {
        type: AudioParamDSP.SET_TARGET_AT_TIME,
        time: startTime,
        args: [target, startTime, timeConstant],
        startFrame: Math.round(startTime * this.sampleRate),
        endFrame: Infinity,
        startValue: 0,
        endValue: target
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case AudioParamDSP.SET_VALUE_AT_TIME:
            eventItem.startValue = prevEventItem.endValue;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case AudioParamDSP.SET_TARGET_AT_TIME:
            eventItem.startValue = 0;
            prevEventItem.endFrame = eventItem.startFrame;
            break;
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.SET_VALUE_CURVE_AT_TIME:
            eventItem.startValue = prevEventItem.endValue;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.startFrame;
            nextEventItem.startValue = eventItem.startValue;
            break;
        }
        eventItem.endFrame = nextEventItem.startFrame;
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {Float32Array[]} values
     * @param {number}         startTime
     * @param {number}         duration
     */

  }, {
    key: "setValueCurveAtTime",
    value: function setValueCurveAtTime(values, startTime, duration) {
      startTime = Math.max(0, util.toNumber(startTime));
      duration = Math.max(0, util.toNumber(duration));

      if (values.length === 0 || duration === 0) {
        return;
      }

      var eventItem = {
        type: AudioParamDSP.SET_VALUE_CURVE_AT_TIME,
        time: startTime,
        args: [values, startTime, duration],
        startFrame: Math.round(startTime * this.sampleRate),
        endFrame: Math.round((startTime + duration) * this.sampleRate),
        startValue: values[0],
        endValue: values[values.length - 1]
      };
      var index = this.insertEvent(eventItem);
      var prevEventItem = this._timeline[index - 1];
      var nextEventItem = this._timeline[index + 1];

      if (prevEventItem) {
        switch (prevEventItem.type) {
          case AudioParamDSP.SET_VALUE_AT_TIME:
          case AudioParamDSP.SET_TARGET_AT_TIME:
            prevEventItem.endFrame = eventItem.startFrame;
            break;
        }
      }

      if (nextEventItem) {
        switch (nextEventItem.type) {
          case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
            nextEventItem.startFrame = eventItem.startFrame;
            nextEventItem.startValue = eventItem.endValue;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @param {number} startTime
     */

  }, {
    key: "cancelScheduledValues",
    value: function cancelScheduledValues(startTime) {
      startTime = Math.max(0, util.toNumber(startTime));

      this._timeline = this._timeline.filter(function (eventItem) {
        return eventItem.time < startTime;
      });

      var index = this._timeline.length - 1;
      var lastEventItem = this._timeline[index];

      if (lastEventItem) {
        switch (lastEventItem.type) {
          case AudioParamDSP.SET_VALUE_AT_TIME:
          case AudioParamDSP.SET_TARGET_AT_TIME:
            lastEventItem.endFrame = Infinity;
            break;
        }
      }

      if (index <= this._currentEventIndex) {
        this._currentEventIndex = index;
        this._remainSamples = 0;
      }
    }

    /**
     * @return {string}
     */

  }, {
    key: "getRate",
    value: function getRate() {
      return this.toRateName(this._rate);
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "hasSampleAccurateValues",
    value: function hasSampleAccurateValues() {
      return this._hasSampleAccurateValues;
    }

    /**
     * @return {Float32Array}
     */

  }, {
    key: "getSampleAccurateValues",
    value: function getSampleAccurateValues() {
      return this.outputBus.getChannelData()[0];
    }

    /**
     *
     */

  }, {
    key: "enableOutputsIfNecessary",
    value: function enableOutputsIfNecessary() {}

    /**
     *
     */

  }, {
    key: "disableOutputsIfNecessary",
    value: function disableOutputsIfNecessary() {}

    /**
     * @return {boolean}
     */

  }, {
    key: "isConnectedFrom",
    value: function isConnectedFrom() {
      var args = Array.from(arguments);

      if (args[0] && args[0].isConnectedTo) {
        return args[0].isConnectedTo.apply(args[0], [this].concat(args.slice(1)));
      }

      return false;
    }

    /**
     * @return {object[]}
     */

  }, {
    key: "getTimeline",
    value: function getTimeline() {
      return this._timeline;
    }

    /**
     * @return {object[]}
     */

  }, {
    key: "getEvents",
    value: function getEvents() {
      var _this = this;

      return this._timeline.map(function (event) {
        return {
          type: _this.toMethodName(event.type),
          time: event.time,
          args: event.args
        };
      });
    }

    /**
     * @param {object}
     * @return {number}
     */

  }, {
    key: "insertEvent",
    value: function insertEvent(eventItem) {
      var time = eventItem.time;
      var timeline = this._timeline;

      if (timeline.length === 0 || timeline[timeline.length - 1].time < time) {
        timeline.push(eventItem);
        return timeline.length - 1;
      }

      var pos = 0;
      var replace = 0;

      while (pos < timeline.length) {
        if (timeline[pos].time === time && timeline[pos].type === eventItem.type) {
          replace = 1;
          break;
        }
        if (time < timeline[pos].time) {
          break;
        }
        pos += 1;
      }

      timeline.splice(pos, replace, eventItem);

      return pos;
    }

    /**
     * @param {string} value
     * @return {number}
     */

  }, {
    key: "fromRateName",
    value: function fromRateName(value) {
      if (value === "audio") {
        return AudioParamDSP.AUDIO;
      }
      return AudioParamDSP.CONTROL;
    }

    /**
     * @param {number} value
     * @return {string}
     */

  }, {
    key: "toRateName",
    value: function toRateName(value) {
      if (value === AudioParamDSP.AUDIO) {
        return "audio";
      }
      return "control";
    }

    /**
     * @param {number} value
     * @return {string}
     */

  }, {
    key: "toMethodName",
    value: function toMethodName(value) {
      switch (value) {
        case AudioParamDSP.SET_VALUE_AT_TIME:
          return "setValueAtTime";
        case AudioParamDSP.LINEAR_RAMP_TO_VALUE_AT_TIME:
          return "linearRampToValueAtTime";
        case AudioParamDSP.EXPONENTIAL_RAMP_TO_VALUE_AT_TIME:
          return "exponentialRampToValueAtTime";
        case AudioParamDSP.SET_TARGET_AT_TIME:
          return "setTargetAtTime";
        case AudioParamDSP.SET_VALUE_CURVE_AT_TIME:
          return "setValueCurveAtTime";
      }
      /* istanbul ignore next */
    }
  }]);

  return AudioParam;
}();

Object.assign(AudioParam.prototype, AudioParamDSP);

module.exports = AudioParam;