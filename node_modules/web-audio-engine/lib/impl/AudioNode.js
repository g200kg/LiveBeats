"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var util = require("../util");
var EventTarget = require("./EventTarget");
var AudioNodeInput = require("./core/AudioNodeInput");
var AudioNodeOutput = require("./core/AudioNodeOutput");
var AudioParam = require("./AudioParam");

/**
 * @prop {AudioContext}      context
 * @prop {number}            blockSize
 * @prop {number}            sampleRate
 * @prop {AudioNodeInput[]}  inputs
 * @prop {AudioNodeOutput[]} outputs
 */

var AudioNode = function (_EventTarget) {
  _inherits(AudioNode, _EventTarget);

  /**
   * @param {AudioContext} context
   * @param {number[]}     opts.inputs
   * @param {number[]}     opts.outputs
   * @param {number}       opts.channelCount
   * @param {string}       opts.channelCountMode
   */

  function AudioNode(context, opts) {
    _classCallCheck(this, AudioNode);

    opts = opts || /* istanbul ignore next */{};

    var inputs = util.defaults(opts.inputs, []);
    var outputs = util.defaults(opts.outputs, []);
    var channelCount = util.defaults(opts.channelCount, 1);
    var channelCountMode = util.defaults(opts.channelCountMode, "max");

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(AudioNode).call(this));

    _this.context = context;
    _this.blockSize = context.blockSize;
    _this.sampleRate = context.sampleRate;
    _this.inputs = [];
    _this.outputs = [];
    _this.currentSampleFrame = -1;

    _this._params = [];
    _this._enabled = false;
    _this._suicideAtSampleFrame = Infinity;

    inputs.forEach(function (numberOfChannels) {
      _this.addInput(numberOfChannels, channelCount, channelCountMode);
    });
    outputs.forEach(function (numberOfChannels) {
      _this.addOutput(numberOfChannels);
    });
    return _this;
  }

  /**
   * @return {number}
   */


  _createClass(AudioNode, [{
    key: "getNumberOfInputs",
    value: function getNumberOfInputs() {
      return this.inputs.length;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getNumberOfOutputs",
    value: function getNumberOfOutputs() {
      return this.outputs.length;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getChannelCount",
    value: function getChannelCount() {
      return this.inputs[0].getChannelCount();
    }

    /**
     * @param {number} value
     */

  }, {
    key: "setChannelCount",
    value: function setChannelCount(value) {
      this.inputs[0].setChannelCount(value);
    }

    /**
     * @return {string}
     */

  }, {
    key: "getChannelCountMode",
    value: function getChannelCountMode() {
      return this.inputs[0].getChannelCountMode();
    }

    /**
     * @param {string} value
     */

  }, {
    key: "setChannelCountMode",
    value: function setChannelCountMode(value) {
      this.inputs[0].setChannelCountMode(value);
    }

    /**
     * @return {string}
     */

  }, {
    key: "getChannelInterpretation",
    value: function getChannelInterpretation() {
      return this.inputs[0].getChannelInterpretation();
    }

    /**
     * @param {string} value
     */

  }, {
    key: "setChannelInterpretation",
    value: function setChannelInterpretation(value) {
      this.inputs[0].setChannelInterpretation(value);
    }

    /**
     * @param {AudioNode|AudioParam} destination
     * @param {number}               output
     * @param {number}               input
     */

  }, {
    key: "connect",
    value: function connect(destination, output, input) {
      this.outputs[output | 0].connect(destination, input | 0);
    }

    /**
     *
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var args = Array.from(arguments);

      if (args.length === 0) {
        return this.disconnectAll();
      }
      if (typeof args[0] === "number") {
        return this.disconnectAllFromOutput(args[0] | 0);
      }
      if (args.length === 1) {
        return this.disconnectIfConnected(args[0]);
      }
      return this.disconnectFromOutputIfConnected(args[1] | 0, args[0], args[2] | 0);
    }

    /**
     * @param {number} numberOfChannels
     * @param {number} channelCount
     * @param {string} channelCountMode
     * @return {AudioNodeInput}
     */

  }, {
    key: "addInput",
    value: function addInput(numberOfChannels, channelCount, channelCountMode) {
      var node = this;
      var index = this.inputs.length;
      var input = new AudioNodeInput({ node: node, index: index, numberOfChannels: numberOfChannels, channelCount: channelCount, channelCountMode: channelCountMode });

      this.inputs.push(input);

      return input;
    }

    /**
     * @param {number} numberOfChannels
     * @return {AudioNodeOutput}
     */

  }, {
    key: "addOutput",
    value: function addOutput(numberOfChannels) {
      var node = this;
      var index = this.outputs.length;
      var output = new AudioNodeOutput({ node: node, index: index, numberOfChannels: numberOfChannels });

      this.outputs.push(output);

      return output;
    }

    /**
     * @param {string} rate - [ "audio", "control" ]
     * @param {number} defaultValue
     * @return {AudioParam}
     */

  }, {
    key: "addParam",
    value: function addParam(rate, defaultValue) {
      var param = new AudioParam(this.context, { rate: rate, defaultValue: defaultValue });

      this._params.push(param);

      return param;
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._enabled;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getTailTime",
    value: function getTailTime() {
      return 0;
    }

    /**
     *
     */

  }, {
    key: "enableOutputsIfNecessary",
    value: function enableOutputsIfNecessary() {
      if (!this._enabled) {
        this._suicideAtSampleFrame = Infinity;
        this._enabled = true;
        this.outputs.forEach(function (output) {
          output.enable();
        });
      }
    }

    /**
     *
     */

  }, {
    key: "disableOutputsIfNecessary",
    value: function disableOutputsIfNecessary() {
      var currentTime = this.context.currentTime;
      var disableAtTime = currentTime + this.getTailTime();

      if (disableAtTime === currentTime) {
        this._disableOutputsIfNecessary();
      } else if (disableAtTime !== Infinity) {
        this._suicideAtSampleFrame = Math.round(disableAtTime * this.sampleRate);
      }
    }

    /**
     * @private
     */

  }, {
    key: "_disableOutputsIfNecessary",
    value: function _disableOutputsIfNecessary() {
      if (this._enabled) {
        this._enabled = false;
        this.outputs.forEach(function (output) {
          output.disable();
        });
      }
    }

    /**
     *
     */

  }, {
    key: "channelDidUpdate",
    value: function channelDidUpdate() {}

    /**
     *
     */

  }, {
    key: "disconnectAll",
    value: function disconnectAll() {
      this.outputs.forEach(function (output) {
        output.disconnect();
      });
    }

    /**
     * @param {number} output
     */

  }, {
    key: "disconnectAllFromOutput",
    value: function disconnectAllFromOutput(output) {
      this.outputs[output | 0].disconnect();
    }

    /**
     * @param {AudioNode|AudioParam} destination
     */

  }, {
    key: "disconnectIfConnected",
    value: function disconnectIfConnected(destination) {
      this.outputs.forEach(function (output) {
        output.disconnect(destination);
      });
    }

    /**
     * @param {number} output
     * @param {AudioNode|AudioParam} destination
     * @param {number} output
     */

  }, {
    key: "disconnectFromOutputIfConnected",
    value: function disconnectFromOutputIfConnected(output, destination, input) {
      this.outputs[output | 0].disconnect(destination, input | 0);
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "isConnectedTo",
    value: function isConnectedTo() {
      var args = Array.from(arguments);

      if (args.length === 1) {
        return this.outputs.some(function (output) {
          return output.isConnectedTo(args[0]);
        });
      }

      var output = args.splice(1, 1)[0] | 0;

      if (this.outputs[output]) {
        return this.outputs[output].isConnectedTo.apply(this.outputs[output], args);
      }

      return false;
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "isConnectedFrom",
    value: function isConnectedFrom() {
      var args = Array.from(arguments);

      if (args[0] && args[0].isConnectedTo) {
        return args[0].isConnectedTo.apply(args[0], [this].concat(args.slice(1)));
      }

      return false;
    }

    /**
     *
     */

  }, {
    key: "processIfNecessary",
    value: function processIfNecessary() {
      var _this2 = this;

      // prevent infinite loop when audio graph has feedback
      if (this.context.currentSampleFrame <= this.currentSampleFrame) {
        return;
      }
      this.currentSampleFrame = this.context.currentSampleFrame;

      if (this._suicideAtSampleFrame <= this.currentSampleFrame) {
        var outputs = this.outputs;

        for (var i = 0, imax = outputs.length; i < imax; i++) {
          outputs[i].zeros();
        }

        this.context.addPostProcess(function () {
          _this2._disableOutputsIfNecessary();
        });
        return;
      }

      var inputs = this.inputs;

      for (var _i = 0, _imax = inputs.length; _i < _imax; _i++) {
        inputs[_i].pull();
      }

      var params = this._params;

      for (var _i2 = 0, _imax2 = params.length; _i2 < _imax2; _i2++) {
        params[_i2].dspProcess();
      }

      this.dspProcess();
    }
  }, {
    key: "dspInit",
    value: function dspInit() {}
  }, {
    key: "dspProcess",
    value: function dspProcess() {}
  }]);

  return AudioNode;
}(EventTarget);

module.exports = AudioNode;