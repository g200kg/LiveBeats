"use strict";

var Buffer = global.Buffer;
var PCMArrayBufferWriter = require("./PCMArrayBufferWriter");
var PCMBufferWriter = require("./PCMBufferWriter");
var PCMWriter = getPCMWriter();
var alloc = getAllocFunction();

function create(length, format) {
  var bitDepth = resolveBitDepth(format.bitDepth, format.float);
  var methodName = resolveWriteMethodName(bitDepth, format.float);
  var bytes = format.bitDepth >> 3;
  var numberOfChannels = format.channels;
  var bufferLength = numberOfChannels * length * bytes;

  if (numberOfChannels === 1) {
    return {
      encode: function encode(channelData) {
        var buffer = alloc(bufferLength);
        var writer = new PCMWriter(buffer);
        var output = channelData[0];

        for (var i = 0, imax = length; i < imax; i++) {
          writer[methodName](output[i]);
        }

        return buffer;
      }
    };
  }

  if (numberOfChannels === 2) {
    return {
      encode: function encode(channelData) {
        var buffer = alloc(bufferLength);
        var writer = new PCMWriter(buffer);
        var outputL = channelData[0];
        var outputR = channelData[1];

        for (var i = 0, imax = length; i < imax; i++) {
          writer[methodName](outputL[i]);
          writer[methodName](outputR[i]);
        }

        return buffer;
      }
    };
  }

  return {
    encode: function encode(channelData) {
      var buffer = alloc(bufferLength);
      var writer = new PCMWriter(buffer);

      for (var i = 0, imax = length; i < imax; i++) {
        for (var ch = 0; ch < numberOfChannels; ch++) {
          writer[methodName](channelData[ch][i]);
        }
      }

      return buffer;
    }
  };
}

/* istanbul ignore next */
function resolveBitDepth(bitDepth, float) {
  return float ? 32 : bitDepth;
}

/* istanbul ignore next */
function resolveWriteMethodName(bitDepth, float) {
  if (float) {
    return "pcm32f";
  }
  return "pcm" + bitDepth;
}

/* istanbul ignore next */
function getPCMWriter() {
  return Buffer ? PCMBufferWriter : PCMArrayBufferWriter;
}

/* istanbul ignore next */
function getAllocFunction() {
  return Buffer ? Buffer.alloc ? Buffer.alloc : newBuffer : newArrayBuffer;
}

/* istanbul ignore next */
function newBuffer(size) {
  return new Buffer(size);
}

/* istanbul ignore next */
function newArrayBuffer(size) {
  return new Uint8Array(size).buffer;
}

module.exports = { create: create };