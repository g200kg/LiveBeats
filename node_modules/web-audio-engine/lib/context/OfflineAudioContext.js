"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var util = require("../util");
var audioDataUtil = require("../util/audioDataUtil");
var AudioContext = require("../api/AudioContext");
var AudioBuffer = require("../api/AudioBuffer");
var setImmediate = require("../util/setImmediate");

var OfflineAudioContext = function (_AudioContext) {
  _inherits(OfflineAudioContext, _AudioContext);

  /**
   * @param {number} numberOfChannels
   * @param {number} length
   * @param {number} sampleRate
   */

  function OfflineAudioContext(numberOfChannels, length, sampleRate) {
    _classCallCheck(this, OfflineAudioContext);

    numberOfChannels = util.toValidNumberOfChannels(numberOfChannels);
    length = Math.max(0, length | 0);
    sampleRate = util.toValidSampleRate(sampleRate);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(OfflineAudioContext).call(this, { sampleRate: sampleRate, numberOfChannels: numberOfChannels }));

    _this._impl.$oncomplete = null;

    util.defineProp(_this, "_numberOfChannels", numberOfChannels);
    util.defineProp(_this, "_length", length);
    util.defineProp(_this, "_suspendedTime", Infinity);
    util.defineProp(_this, "_suspendPromise", null);
    util.defineProp(_this, "_suspendResolve", null);
    util.defineProp(_this, "_renderingPromise", null);
    util.defineProp(_this, "_renderingResolve", null);
    util.defineProp(_this, "_renderingIterations", 128);
    util.defineProp(_this, "_audioData", null);
    util.defineProp(_this, "_writeIndex", 0);
    return _this;
  }

  /**
   * @return {function}
   */


  _createClass(OfflineAudioContext, [{
    key: "resume",


    /**
     * @return {Promise<void>}
     */
    value: function resume() {
      /* istanbul ignore next */
      if (this._impl.state === "closed") {
        return Promise.reject(new TypeError("cannot startRendering when an OfflineAudioContext is closed"));
      }
      /* istanbul ignore next */
      if (this._renderingPromise === null) {
        return Promise.reject(new TypeError("cannot resume an offline context that has not started"));
      }
      /* istanbul ignore else */
      if (this._impl.state === "suspended") {
        render.call(this, this._impl);
      }
      return Promise.resolve();
    }

    /**
     * @param {number} time
     * @return {Promise<void>}
     */

  }, {
    key: "suspend",
    value: function suspend(time) {
      var _this2 = this;

      /* istanbul ignore next */
      if (this._impl.state === "closed") {
        return Promise.reject(new TypeError("cannot startRendering when an OfflineAudioContext is closed"));
      }
      /* istanbul ignore next */
      if (this._suspendPromise !== null) {
        return Promise.reject(new TypeError("cannot schedule more than one suspend"));
      }

      time = Math.max(0, util.toNumber(time));

      this._suspendedTime = time;
      this._suspendPromise = new Promise(function (resolve) {
        _this2._suspendResolve = resolve;
      });

      return this._suspendPromise;
    }

    /**
     * @return {Promise<void>}
     */
    /* istanbul ignore next */

  }, {
    key: "close",
    value: function close() {
      return Promise.reject(new TypeError("cannot close an OfflineAudioContext"));
    }

    /**
     * @return {Promise<AudioBuffer>}
     */

  }, {
    key: "startRendering",
    value: function startRendering() {
      var _this3 = this;

      /* istanbul ignore next */
      if (this._impl.state === "closed") {
        return Promise.reject(new TypeError("cannot startRendering when an OfflineAudioContext is closed"));
      }
      /* istanbul ignore next */
      if (this._renderingPromise !== null) {
        return Promise.reject(new TypeError("cannot call startRendering more than once"));
      }

      this._renderingPromise = new Promise(function (resolve) {
        var numberOfChannels = _this3._numberOfChannels;
        var length = _this3._length;
        var sampleRate = _this3.sampleRate;
        var blockSize = _this3._impl.blockSize;

        _this3._audioData = createRenderingAudioData(numberOfChannels, length, sampleRate, blockSize);
        _this3._renderingResolve = resolve;

        render.call(_this3, _this3._impl);
      });

      return this._renderingPromise;
    }
  }, {
    key: "oncomplete",
    get: function get() {
      return this._impl.$oncomplete;
    }

    /**
     * @param {function} callback
     */
    ,
    set: function set(callback) {
      this._impl.replaceEventListener("complete", this._impl.$oncomplete, callback);
      this._impl.$oncomplete = callback;
    }
  }]);

  return OfflineAudioContext;
}(AudioContext);

function createRenderingAudioData(numberOfChannels, length, sampleRate, blockSize) {
  length = Math.ceil(length / blockSize) * blockSize;

  var channelData = Array.from({ length: numberOfChannels }, function () {
    return new Float32Array(length);
  });

  return { numberOfChannels: numberOfChannels, length: length, sampleRate: sampleRate, channelData: channelData };
}

function suspendRendering() {
  this._suspendResolve();
  this._suspendedTime = Infinity;
  this._suspendPromise = this._suspendResolve = null;
  this._impl.changeState("suspended");
}

function doneRendering(audioData) {
  var length = this._length;

  audioData.channelData = audioData.channelData.map(function (channelData) {
    return channelData.subarray(0, length);
  });
  audioData.length = length;

  var audioBuffer = audioDataUtil.toAudioBuffer(audioData, AudioBuffer);

  this._impl.changeState("closed");
  this._impl.dispatchEvent({ type: "complete", renderedBuffer: audioBuffer });

  this._renderingResolve(audioBuffer);
  this._renderingResolve = null;
}

function render(impl) {
  var _this4 = this;

  var audioData = this._audioData;
  var audioDataLength = audioData.length;
  var channelData = audioData.channelData;
  var blockSize = impl.blockSize;
  var renderingIterations = this._renderingIterations;

  var writeIndex = this._writeIndex;

  var loop = function loop() {
    var remainIterations = (audioDataLength - writeIndex) / blockSize;
    var iterations = Math.min(renderingIterations, remainIterations) | 0;

    for (var i = 0; i < iterations; i++) {
      if (_this4._suspendedTime <= impl.currentTime) {
        _this4._writeIndex = writeIndex;
        return suspendRendering.call(_this4);
      } else {
        impl.process(channelData, writeIndex);
        writeIndex += blockSize;
      }
    }
    _this4._writeIndex = writeIndex;

    if (writeIndex === audioDataLength) {
      doneRendering.call(_this4, audioData);
    } else {
      setImmediate(loop);
    }
  };

  impl.changeState("running");

  setImmediate(loop);
}

module.exports = OfflineAudioContext;